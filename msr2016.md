### Pony: Co-Designing a Type System and a Runtime

Sylvan Clebsch

March 29th, 2016

-----

Presenting at Microsoft Research, Cambridge

---

### My background

24 years of industry programming

Electronic trading, online video games, crypto tools, physics modelling, rendering engines, military sims, VOIP, peer routing, embedded operating systems.

----

### These all have something in common

Performance critical

Benefit from concurrency

Most are actually distributed systems...

<!-- .element: class="fragment"--> _...even if I didn't realise that when writing them_

----

### Current work: Pony

An actor-model capabilities-secure native programming language

Designed to "scratch my own itch"

---

### What is Pony?

```pony
actor Main
  new create(env: Env) =>
    env.out.print("Hello, Cambridge!")
```

----

### Goals

Statically data-race free, with mutability

No-stop-the-world garbage collection

Formally specified

Single node performance competitive with C/C++

Distributed computing

----

### Some good domains for Pony

Financial systems

Video games

Stream processing

Machine learning

Low-power devices (speed is energy efficiency)

Operating systems

---

### Let's walk through that example

```pony
actor Main
  new create(env: Env) =>
    env.out.print("Hello, Cambridge!")
```

`env` is an _immutable environment_ that encapsulates command line arguments, environment variables, `stdin`, `stdout`, `stderr`

There are no globals, as globals represent _ambient authority_

Access to `stdout` must be passed to any function that needs it

----

### Capabilities security

Originally operating system based: KeyKOS, EROS, Coyotos, seL4

Expanded to programming languages with _object capabilities_ (ocaps): E, AmbientTalk, Caja

Pony is an ocap language: `env` is an ocap for the initial environment

----

### Reference capabilities

Pony extends ocaps with _reference capabilities_ (rcaps)

For example, the immutability of `env` is an rcap: more on this later!

----

### Actor model

```pony
actor Main
  new create(env: Env) =>
    env.out.print("Hello, Cambridge!")
```

`env.out` is an _actor_ that encapsulates `stdout`

Instead of locking `stdout` to print, a message is sent to the actor containing what is to be printed

Here, the message is `print` and we print `"Hello, Cambridge!"`

----

### Actor model history

Starts with Carl Hewitt in 1973

Gul Agha's 1985 thesis provided a foundational model

Closely connected to CSP, pi-calculus, join-calculus

Some other actor languages: Erlang, E, AmbientTalk, JavaScript

Some actor libraries: Akka, Orleans, ActorFoundry, CAF

----

### Why is it safe to send a String in a message?

```pony
actor Main
  new create(env: Env) =>
    env.out.print("Hello, Cambridge!")
```

Here, we are passing a string literal, which has the type `String val`

The `val` means it is a _globally immutable_ `String`: there can be no writeable aliases to the object

It's safe to send `val` references in messages: there will be no data races

<!-- .element: class="fragment"--> `val` is a _reference capability_ (rcap)

----

### What about sending mutable data in messages?

```pony
actor TCPConnection
  new create(notify: TCPConnectionNotify iso, 
    host: String, service: String, from: String = "")
```

When creating a `TCPConnection`, we attach a `TCPConnectionNotify` that will be called when events occur on the connection

`notify` may need to mutate its state: for example, it may do stateful protocol decoding

----

### Isolation for data-race free mutability

```pony
actor TCPConnection
  new create(notify: TCPConnectionNotify iso, 
    host: String, service: String, from: String = "")
```

To make this safe, `TCPConnection` requires that `notify` is _isolated_ (`iso`).

`iso` guarantees there are no readable or writeable aliases to the object

It's safe to send `iso` references in messages

----

### Using `tag` to express identity

```pony
actor Timers
  be apply(timer: Timer iso)
  be cancel(timer: Timer tag)
```

When setting up a `Timer`, a `Timers` actor represents a set of hierarchical timing wheels and manages the underlying OS timer mechanism

A `Timer` is mutable, not only to change when it next fires, but because it holds a mutable `TimerNotify` that is informed of events that may in turn hold mutable state

----

### `tag` is compatible with `iso`

```pony
actor Timers
  be apply(timer: Timer iso)
  be cancel(timer: Timer tag)
```

We can send a `Timer iso` to another actor while safely keeping a `tag` alias: `tag` is opaque, allowing neither reading from nor writing to the object

Sending a `tag` in a message is also safe: an opaque reference can't be the source of data races

----

### Using `tag` to type actors

```pony
actor Main
  new create(env: Env) =>
    env.out.print("Hello, Cambridge!")
```

Here, the `env.out` actor is a `StdStream tag`

Sending an asynchronous message involves neither reading from nor writing to the receiver's state

----

### Actors are part of the rcap system

```pony
actor Timers
  be apply(timer: Timer iso) =>
    """
    Sets a timer. Fire it if need be, schedule it on the right timing wheel,
    then rearm the timer.
    """
    let timer': Timer ref = consume timer
    _map(timer') = timer'
    timer'._slop(_slop)
    _fire(timer')
    _advance()
```

Here we see a behaviour (`be`) that handles the `apply` message

When a behaviour executes, `this` is typed as `ref`: the actor can freely mutate its own state

---

### Data-race freedom

> "If I can write to it, nobody else can read from it"

Corollary:

> "If I can read from it, nobody else can write to it"

----

### Existing data-race freedom work

Gordon, Parkinson, Parsons, Bromfield, Duffy: _Uniqueness and reference immutability for safe parallelism_

Östlund, Wrigstad, Clarke, Åkerblom: _Ownership, uniqueness, and immutability_

Haller, Odersky: _Capabilities for uniqueness and borrowing_

Srinivasan, Mycroft: _Kilim: Isolation-typed actors for java_

Wadler: _Linear types can change the world_

Rust: mixed static/dynamic data race freedom

----

### Deny rather than allow

Pony's _reference capabilities_ (rcaps) express what other aliases cannot exist, both locally and globally

Alias denial appears to be more fundamental than permissions

----

### Deny matrix

| Deny global | aliases | |
-----------------------|--------------|-------------|-----
__Deny local aliases__ | _Read/Write_ | _Write_     | _None_
_Read/Write_           | __*iso*__    |             |
_Write_                | __trn__      | __*val*__   |
_None_                 | __ref__      | __box__     | __*tag*__
                       | _mutable_    | _immutable_ | _opaque_

----

### Rcap compatibility

Adrian Colyer's chart from The Morning Paper

![Deny Capabilities](img/pony-deny-capabilities.png)

----

### Rcaps and viewpoint adaptation

```pony
class HashMap[K, V, H: HashFunction[K] val]
  fun apply(key: box->K!): this->V ?
```

Here, the `key` is any _alias_ (`!`) of how a _readable_ (`box`) type would see the unconstrained type variable `K`

The return value is how the receiver seees the type variable `V`

This is a _partial function_ (`?`): this is how exceptions work in Pony

----

### Rcaps, ephemerality, algebraic data types

```pony
class HashMap[K, V, H: HashFunction[K] val]
  fun ref update(key: K, value: V): (V^ | None) =>
```

In contrast, here an actual `key: K` is required, as the `HashMap` will store it

The return value is an _ephemeral_ (`^`) `V`: the `HashMap` promises that one alias has been removed (the one the `HashMap` previously held, if any) or `None` if no value was previously associated with the key

----

### An example of ephemerality

```pony
let ant: Ant val = ...
let map: HashMap[String, Aardvark iso] = ...
map("bob").eat(ant) // ok
let bob1: Aardvark iso = map("bob") // bad!
let bob2: Aardvark tag = map("bob") // ok
let bob3: Aardvark iso = map.remove("bob") // ok
```

We can lookup Bob the Aardvark and call `iso`-safe functions on the result

But we can't take an alias to Bob, except as a `tag`

But we could remove Bob from the map entirely

---

### Formalism at the root

There has been a tight feedback loop between research and development

The formalism has improved the implementation

The implementation has improved the formalism

----

### Operational semantics

<img src="img/opsem.png" width=800>

----

### Type system

![Type system](img/typesystem.png)

---

### Leveraging the type system in the runtime

Types as guarantees help reasoning

Those same guarantees can be used in the runtime implementation

_Type systems can improve performance_

----

### What parts of the runtime are faster due to the type system?

Memory allocator

Garbage collector

Message queues

Work-stealing scheduler

Asynchronous I/O

---

### Garbage collection

Per-actor heaps, separately collected

No system-wide GC pauses

TODO:

---

### TODO: distribution outlook

---

### What's the development status?

Concurrent Pony is ready and in use

Runs on everything from Raspberry Pi to 4096 core SGI, Windows, OSX, Linux, FreeBSD

Performance is competitive with C/C++

Currently working on Distributed Pony

----

### Formal work in progress

* Continued formalisation work in cooperation with Sophia Drossopoulou, Imperial College London
* Formalise ORCA protocol for collecting passive objects shared across heaps (Juliana Franco, ICL)
* Formalise rcap interaction with algebraic and parameterised types (George Steed, ICL)
* Formalise simple value dependent types (Luke Cheeseman, ICL)
* Formalise capabilities-secure reflection, type system for machine-specific data, distributed object identity, distributed GC protocol extensions (me)

----

### Implementation work in progress

* Distributed runtime
* Simple value dependent types
* Capabities-secure reflection
* Hot code loading
* REPL
* Package manager
* Auto formatting
* Self-hosted compiler

---

### TODO: conclusion

---

### TODO: performance graphs
